NOTES
--------------

2a. Rendering a collection, modules
    Always use functional programming operaters with arrays (find, filter, map)

    Generate React elements from array objects
        Key attribute - used to determine how to update the view generated 
        by a component when the component is re-rendered
            Each child in an array or any iterator should have a unique 
            `key` prop

            Errors: notes.map(note => <li>{note.content}</li>)

            Works: notes.map(note => <li key={note.id}>{note.content}</li>)

        Using Array Index as Key - Not recommended!
            Will technically work in most cases, but can lead to issues

    Components commonly defined in src/components/
        Referenced from other components (or App.jsx) like so:
            import Note from './components/Note'

            location is always given in relation to the importing file

2b. Forms
    Basic form syntax:
        <form onSubmit={eventHandler}>
            <input type='text' />
            <button type="submit">Save</button>
        </form> 

        basic event handler:
            const eventHandler = (event) => {
                event.preventDefault()
                console.log('button clicked', event.target)
            }
    
    Controlled Components - method for extracting form inputs
        Add a new piece of state and set it to the `value` attribute of 
        the input element along with an event handler assigned to the 
        `onChange` attribute 

        Form definition:
            <input value={newValue} onChange={handleInputChange} />
        
        Event Handler:
            const handleInputChange = (event) => {
                console.log(event.target.value)
                setNewValue(event.target.value)
            }

            event.preventDefault() is not needed here because there is no 
            default action for an input change

2c. Getting data from server
    json-server - developement tool that allows you to interact with a 
    local json file as if it was a database
        npm install json-server --save-dev
            --save-dev when only in use for development

        Create db.json file in root directory

        command in root: npx json-server --port 3001 db.json

        OR add `"server": "json-server -p 3001 db.json"` to `scripts` 
        in package.json and use `npm run server`

    Axios - npm install axios   
        Promise - A Promise is an object representing the 
        eventual completion or failure of an asynchronous operation.
            Axios requests typically return a promise

            Promise states: pending, fulfilled, rejected

            The result of the operation represented by a promise 
            is accessed by registering an event handler to the promise
                promise.then(response => {
                    console.log(response)
                })
            
            Storing the promise object in a var is generally unnecessary
                axios
                    .get('http://localhost:3001/notes')
                    .then(response => {
                        const notes = response.data
                        console.log(notes)
                    })
    Effect hooks - effects let a component connect/sync with external systems
        ex: network transactions, browser DOM, animations, 
        widgets using external UI libraries, other non-React code

        Commonly used to fetch data from a server within a component

        By default, effects run after every completed render
            You can set dependencies that cause it to fire when 
            certain values have changed

2d. Altering data in server
    RESTful API
        Resources - individual data object (like the notes in example application)
            Each has a unique address associated (url)
                /notes -> returns all notes
                /notes/3 -> returns note with id = 3
        
        Resources are fetched using HTTP GET requests

        New resources are created using HTTP POST requests

    Axios POST Request - second argument is the payload to post
        axios.post('http://localhost:3001/notes', noteObject)

    Extracting Backend Communication into Separate Module
        Single Responsibility Principle
            Each module or function should have one responsibility.
            For backend communication, create a separate file (e.g., 
            services/notes.js) to handle all server requests.

            Example:
            // services/notes.js
            import axios from 'axios'
            const baseUrl = 'http://localhost:3001/notes'

            const getAll = () => axios.get(baseUrl).then(res => res.data)
            const create = newObject => {
                axios.post(baseUrl, newObject).then(res => res.data)
            }

            export default { getAll, create }
            Then, import and use these functions in your components to keep 
            data fetching logic separate from UI logic.

    Streamlined syntax for defining object literals
        Typical:
            const name = 'Leevi'
            const age = 0

            const person = {
                name: name,
                age: age
            }
        
        Streamlined: (Applicable whenever variable name is same as key)
            const person = { name, age }
    
    Promises and Errors
        Promise chain - every call to .then returns a new promise, which 
        can have .then called on it again using the previous result/promise

        Catch - .catch is used to define a handler function, which is 
        called once any promise in the chain throws an error (promise > rejected)

2e. Adding Styles to React App
    CSS Basics
        Selectors - defines which elements the rule should apply to
            Class is an attribute of an element that is commonly used as a 
            selector
                CSS syntax: .class-name {}

                In React classes are set by `className` attribute

        Declarations - sets properties to a value
    
    Inline Styles - In React, the `style` attribute expects a JavaScript 
    object, not a CSS string.
        Property names must use camelCase (e.g., fontStyle) instead of 
        kebab-case (e.g., font-style).

        Numeric values for pixels can be defined as integers, while other 
        units must be specified as strings (e.g., padding: '2em').

        Example of normal CSS syntax:
            {
                color: green;
                font-style: italic;
            }
        
        Example of React inline style object:
            {
                color: 'green',
                fontStyle: 'italic'
            }
        Pseudo-classes (like hover) can't be used inline
            Pseudo-class examples:
                :hover, :active, :focus, :visited, :first-child, etc

            Best to use classes + traditional css for this
    
    Where should CSS exist?
        Traditional approach - Content (HTML) and functionality (JS) 
        should be entirely separate from styling (CSS)

        React philosophy - base division of the application along the lines 
        of its logical functional entities (Components)
            Therefore, it is best to define all of these things at the 
            individual component level to make them as independent and 
            reusable as possible.


--------------
Part 2 Lessons Learned:
    - Functional programming operaters with arrays (find, filter, map)
    - Key attribute on React elements from list
    - Define components separately in src/components/
    - Forms 
    - Controlled Components (value controlled by state)
    - JSON-Server
    - Axios 
    - Promises 
    - Effect hooks
    - RESTful API
    - Catch errors

--------------
Final Planning 
    Right Side Panel - toggled by footer
    Content
    Footer Menu

    Content pages:
        Activity Creation
        Activity Logging
        Day Review
